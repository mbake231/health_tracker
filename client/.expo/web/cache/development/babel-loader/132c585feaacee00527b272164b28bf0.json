{"ast":null,"code":"'use strict';\n\nvar _reactJsxRuntime = require(\"react/jsx-runtime\");\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\n\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\n\nvar _defineProperty = require(\"@babel/runtime/helpers/defineProperty\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nvar React = require('react');\n\nvar ReactNative = require(\"react-native-web/dist/index\");\n\nvar View = ReactNative.View,\n    Platform = ReactNative.Platform,\n    StyleSheet = ReactNative.StyleSheet,\n    requireNativeComponent = ReactNative.requireNativeComponent;\n\nvar AnimatedImplementation = require('react-native/Libraries/Animated/src/AnimatedImplementation');\n\nvar ScrollResponder = require('react-native/Libraries/Components/ScrollResponder');\n\nvar ScrollViewStickyHeader = require('react-native/Libraries/Components/ScrollView/ScrollViewStickyHeader');\n\nvar createReactClass = require('create-react-class');\n\nvar dismissKeyboard = require('react-native/Libraries/Utilities/dismissKeyboard');\n\nvar flattenStyle = require('react-native/Libraries/StyleSheet/flattenStyle');\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar processDecelerationRate = require('react-native/Libraries/Components/ScrollView/processDecelerationRate');\n\nvar warning = require('fbjs/lib/warning');\n\nvar resolveAssetSource = require('react-native/Libraries/Image/resolveAssetSource');\n\nvar AndroidScrollView;\nvar AndroidHorizontalScrollContentView;\nvar AndroidHorizontalScrollView;\nvar RCTScrollView;\nvar RCTScrollContentView;\n\nif (Platform.OS === 'android') {\n  AndroidScrollView = requireNativeComponent('RCTNestedScrollView');\n  AndroidHorizontalScrollView = requireNativeComponent('AndroidHorizontalNestedScrollView');\n  AndroidHorizontalScrollContentView = requireNativeComponent('AndroidHorizontalNestedScrollContentView');\n} else if (Platform.OS === 'ios') {\n  RCTScrollView = requireNativeComponent('RCTScrollView');\n  RCTScrollContentView = requireNativeComponent('RCTScrollContentView');\n} else {\n  RCTScrollView = requireNativeComponent('RCTScrollView');\n  RCTScrollContentView = requireNativeComponent('RCTScrollContentView');\n}\n\nfunction createScrollResponder(node) {\n  var scrollResponder = _objectSpread({}, ScrollResponder.Mixin);\n\n  for (var _key in scrollResponder) {\n    if (typeof scrollResponder[_key] === 'function') {\n      scrollResponder[_key] = scrollResponder[_key].bind(node);\n    }\n  }\n\n  return scrollResponder;\n}\n\nvar ScrollView = function (_React$Component) {\n  _inherits(ScrollView, _React$Component);\n\n  var _super = _createSuper(ScrollView);\n\n  function ScrollView(props) {\n    var _this;\n\n    _classCallCheck(this, ScrollView);\n\n    _this = _super.call(this, props);\n    _this._scrollResponder = createScrollResponder(_assertThisInitialized(_this));\n    _this._scrollAnimatedValue = new AnimatedImplementation.Value(0);\n    _this._scrollAnimatedValueAttachment = null;\n    _this._stickyHeaderRefs = new Map();\n    _this._headerLayoutYs = new Map();\n    _this.state = _objectSpread({\n      layoutHeight: null\n    }, ScrollResponder.Mixin.scrollResponderMixinGetInitialState());\n\n    _this._handleScroll = function (e) {\n      if (__DEV__) {\n        if (_this.props.onScroll && _this.props.scrollEventThrottle == null && Platform.OS === 'ios') {\n          console.log('You specified `onScroll` on a <ScrollView> but not ' + '`scrollEventThrottle`. You will only receive one event. ' + 'Using `16` you get all the events but be aware that it may ' + \"cause frame drops, use a bigger number if you don't need as \" + 'much precision.');\n        }\n      }\n\n      if (Platform.OS === 'android') {\n        if (_this.props.keyboardDismissMode === 'on-drag' && _this.state.isTouching) {\n          dismissKeyboard();\n        }\n      }\n\n      _this._scrollResponder.scrollResponderHandleScroll(e);\n    };\n\n    _this._handleLayout = function (e) {\n      if (_this.props.invertStickyHeaders === true) {\n        _this.setState({\n          layoutHeight: e.nativeEvent.layout.height\n        });\n      }\n\n      if (_this.props.onLayout) {\n        _this.props.onLayout(e);\n      }\n    };\n\n    _this._handleContentOnLayout = function (e) {\n      var _e$nativeEvent$layout = e.nativeEvent.layout,\n          width = _e$nativeEvent$layout.width,\n          height = _e$nativeEvent$layout.height;\n      _this.props.onContentSizeChange && _this.props.onContentSizeChange(width, height);\n    };\n\n    _this._scrollViewRef = null;\n\n    _this._setScrollViewRef = function (ref) {\n      _this._scrollViewRef = ref;\n    };\n\n    _this._innerViewRef = null;\n\n    _this._setInnerViewRef = function (ref) {\n      _this._innerViewRef = ref;\n    };\n\n    for (var _key2 in ScrollResponder.Mixin) {\n      if (typeof ScrollResponder.Mixin[_key2] === 'function' && _key2.startsWith('scrollResponder')) {\n        _assertThisInitialized(_this)[_key2] = ScrollResponder.Mixin[_key2].bind(_assertThisInitialized(_this));\n      }\n    }\n\n    Object.keys(ScrollResponder.Mixin).filter(function (key) {\n      return typeof ScrollResponder.Mixin[key] !== 'function';\n    }).forEach(function (key) {\n      _assertThisInitialized(_this)[key] = ScrollResponder.Mixin[key];\n    });\n    return _this;\n  }\n\n  _createClass(ScrollView, [{\n    key: \"UNSAFE_componentWillMount\",\n    value: function UNSAFE_componentWillMount() {\n      this._scrollResponder.UNSAFE_componentWillMount();\n\n      this._scrollAnimatedValue = new AnimatedImplementation.Value(this.props.contentOffset ? this.props.contentOffset.y : 0);\n\n      this._scrollAnimatedValue.setOffset(this.props.contentInset ? this.props.contentInset.top : 0);\n\n      this._stickyHeaderRefs = new Map();\n      this._headerLayoutYs = new Map();\n    }\n  }, {\n    key: \"UNSAFE_componentWillReceiveProps\",\n    value: function UNSAFE_componentWillReceiveProps(nextProps) {\n      var currentContentInsetTop = this.props.contentInset ? this.props.contentInset.top : 0;\n      var nextContentInsetTop = nextProps.contentInset ? nextProps.contentInset.top : 0;\n\n      if (currentContentInsetTop !== nextContentInsetTop) {\n        this._scrollAnimatedValue.setOffset(nextContentInsetTop || 0);\n      }\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this._updateAnimatedNodeAttachment();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      this._updateAnimatedNodeAttachment();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this._scrollAnimatedValueAttachment) {\n        this._scrollAnimatedValueAttachment.detach();\n      }\n    }\n  }, {\n    key: \"setNativeProps\",\n    value: function setNativeProps(props) {\n      this._scrollViewRef && this._scrollViewRef.setNativeProps(props);\n    }\n  }, {\n    key: \"getScrollResponder\",\n    value: function getScrollResponder() {\n      return this;\n    }\n  }, {\n    key: \"getScrollableNode\",\n    value: function getScrollableNode() {\n      return ReactNative.findNodeHandle(this._scrollViewRef);\n    }\n  }, {\n    key: \"getInnerViewNode\",\n    value: function getInnerViewNode() {\n      return ReactNative.findNodeHandle(this._innerViewRef);\n    }\n  }, {\n    key: \"getNativeScrollRef\",\n    value: function getNativeScrollRef() {\n      return this._scrollViewRef;\n    }\n  }, {\n    key: \"scrollTo\",\n    value: function scrollTo(options, deprecatedX, deprecatedAnimated) {\n      var x, y, animated;\n\n      if (typeof options === 'number') {\n        console.warn('`scrollTo(y, x, animated)` is deprecated. Use `scrollTo({x: 5, y: 5, ' + 'animated: true})` instead.');\n        y = options;\n        x = deprecatedX;\n        animated = deprecatedAnimated;\n      } else if (options) {\n        y = options.y;\n        x = options.x;\n        animated = options.animated;\n      }\n\n      this._scrollResponder.scrollResponderScrollTo({\n        x: x || 0,\n        y: y || 0,\n        animated: animated !== false\n      });\n    }\n  }, {\n    key: \"scrollToEnd\",\n    value: function scrollToEnd(options) {\n      var animated = (options && options.animated) !== false;\n\n      this._scrollResponder.scrollResponderScrollToEnd({\n        animated: animated\n      });\n    }\n  }, {\n    key: \"scrollWithoutAnimationTo\",\n    value: function scrollWithoutAnimationTo() {\n      var y = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      console.warn('`scrollWithoutAnimationTo` is deprecated. Use `scrollTo` instead');\n      this.scrollTo({\n        x: x,\n        y: y,\n        animated: false\n      });\n    }\n  }, {\n    key: \"flashScrollIndicators\",\n    value: function flashScrollIndicators() {\n      this._scrollResponder.scrollResponderFlashScrollIndicators();\n    }\n  }, {\n    key: \"_getKeyForIndex\",\n    value: function _getKeyForIndex(index, childArray) {\n      var child = childArray[index];\n      return child && child.key;\n    }\n  }, {\n    key: \"_updateAnimatedNodeAttachment\",\n    value: function _updateAnimatedNodeAttachment() {\n      if (this._scrollAnimatedValueAttachment) {\n        this._scrollAnimatedValueAttachment.detach();\n      }\n\n      if (this.props.stickyHeaderIndices && this.props.stickyHeaderIndices.length > 0) {\n        this._scrollAnimatedValueAttachment = AnimatedImplementation.attachNativeEvent(this._scrollViewRef, 'onScroll', [{\n          nativeEvent: {\n            contentOffset: {\n              y: this._scrollAnimatedValue\n            }\n          }\n        }]);\n      }\n    }\n  }, {\n    key: \"_setStickyHeaderRef\",\n    value: function _setStickyHeaderRef(key, ref) {\n      if (ref) {\n        this._stickyHeaderRefs.set(key, ref);\n      } else {\n        this._stickyHeaderRefs.delete(key);\n      }\n    }\n  }, {\n    key: \"_onStickyHeaderLayout\",\n    value: function _onStickyHeaderLayout(index, event, key) {\n      var stickyHeaderIndices = this.props.stickyHeaderIndices;\n\n      if (!stickyHeaderIndices) {\n        return;\n      }\n\n      var childArray = React.Children.toArray(this.props.children);\n\n      if (key !== this._getKeyForIndex(index, childArray)) {\n        return;\n      }\n\n      var layoutY = event.nativeEvent.layout.y;\n\n      this._headerLayoutYs.set(key, layoutY);\n\n      var indexOfIndex = stickyHeaderIndices.indexOf(index);\n      var previousHeaderIndex = stickyHeaderIndices[indexOfIndex - 1];\n\n      if (previousHeaderIndex != null) {\n        var previousHeader = this._stickyHeaderRefs.get(this._getKeyForIndex(previousHeaderIndex, childArray));\n\n        previousHeader && previousHeader.setNextHeaderY(layoutY);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var ScrollViewClass;\n      var ScrollContentContainerViewClass;\n\n      if (Platform.OS === 'android') {\n        if (this.props.horizontal === true) {\n          ScrollViewClass = AndroidHorizontalScrollView;\n          ScrollContentContainerViewClass = AndroidHorizontalScrollContentView;\n        } else {\n          ScrollViewClass = AndroidScrollView;\n          ScrollContentContainerViewClass = View;\n        }\n      } else {\n        ScrollViewClass = RCTScrollView;\n        ScrollContentContainerViewClass = RCTScrollContentView;\n      }\n\n      invariant(ScrollViewClass !== undefined, 'ScrollViewClass must not be undefined');\n      invariant(ScrollContentContainerViewClass !== undefined, 'ScrollContentContainerViewClass must not be undefined');\n      var contentContainerStyle = [this.props.horizontal === true && styles.contentContainerHorizontal, this.props.contentContainerStyle];\n\n      if (__DEV__ && this.props.style !== undefined) {\n        var style = flattenStyle(this.props.style);\n        var childLayoutProps = ['alignItems', 'justifyContent'].filter(function (prop) {\n          return style && style[prop] !== undefined;\n        });\n        invariant(childLayoutProps.length === 0, 'ScrollView child layout (' + JSON.stringify(childLayoutProps) + ') must be applied through the contentContainerStyle prop.');\n      }\n\n      var contentSizeChangeProps = {};\n\n      if (this.props.onContentSizeChange) {\n        contentSizeChangeProps = {\n          onLayout: this._handleContentOnLayout\n        };\n      }\n\n      var stickyHeaderIndices = this.props.stickyHeaderIndices;\n      var children = this.props.children;\n\n      if (stickyHeaderIndices != null && stickyHeaderIndices.length > 0) {\n        var childArray = React.Children.toArray(this.props.children);\n        children = childArray.map(function (child, index) {\n          var indexOfIndex = child ? stickyHeaderIndices.indexOf(index) : -1;\n\n          if (indexOfIndex > -1) {\n            var _key3 = child.key;\n            var nextIndex = stickyHeaderIndices[indexOfIndex + 1];\n            return _reactJsxRuntime.jsx(ScrollViewStickyHeader, {\n              ref: function ref(_ref) {\n                return _this2._setStickyHeaderRef(_key3, _ref);\n              },\n              nextHeaderLayoutY: _this2._headerLayoutYs.get(_this2._getKeyForIndex(nextIndex, childArray)),\n              onLayout: function onLayout(event) {\n                return _this2._onStickyHeaderLayout(index, event, _key3);\n              },\n              scrollAnimatedValue: _this2._scrollAnimatedValue,\n              inverted: _this2.props.invertStickyHeaders,\n              scrollViewHeight: _this2.state.layoutHeight,\n              children: child\n            }, _key3);\n          } else {\n            return child;\n          }\n        });\n      }\n\n      var hasStickyHeaders = Array.isArray(stickyHeaderIndices) && stickyHeaderIndices.length > 0;\n\n      var contentContainer = _reactJsxRuntime.jsx(ScrollContentContainerViewClass, _objectSpread(_objectSpread({}, contentSizeChangeProps), {}, {\n        ref: this._setInnerViewRef,\n        style: contentContainerStyle,\n        removeClippedSubviews: Platform.OS === 'android' && hasStickyHeaders ? false : this.props.removeClippedSubviews,\n        collapsable: false,\n        children: children\n      }));\n\n      var alwaysBounceHorizontal = this.props.alwaysBounceHorizontal !== undefined ? this.props.alwaysBounceHorizontal : this.props.horizontal;\n      var alwaysBounceVertical = this.props.alwaysBounceVertical !== undefined ? this.props.alwaysBounceVertical : !this.props.horizontal;\n      var DEPRECATED_sendUpdatedChildFrames = !!this.props.DEPRECATED_sendUpdatedChildFrames;\n      var baseStyle = this.props.horizontal === true ? styles.baseHorizontal : styles.baseVertical;\n\n      var props = _objectSpread(_objectSpread({}, this.props), {}, {\n        alwaysBounceHorizontal: alwaysBounceHorizontal,\n        alwaysBounceVertical: alwaysBounceVertical,\n        style: [baseStyle, this.props.style],\n        onContentSizeChange: null,\n        onLayout: this._handleLayout,\n        onMomentumScrollBegin: this._scrollResponder.scrollResponderHandleMomentumScrollBegin,\n        onMomentumScrollEnd: this._scrollResponder.scrollResponderHandleMomentumScrollEnd,\n        onResponderGrant: this._scrollResponder.scrollResponderHandleResponderGrant,\n        onResponderReject: this._scrollResponder.scrollResponderHandleResponderReject,\n        onResponderRelease: this._scrollResponder.scrollResponderHandleResponderRelease,\n        onResponderTerminate: this._scrollResponder.scrollResponderHandleTerminate,\n        onResponderTerminationRequest: this._scrollResponder.scrollResponderHandleTerminationRequest,\n        onScrollBeginDrag: this._scrollResponder.scrollResponderHandleScrollBeginDrag,\n        onScrollEndDrag: this._scrollResponder.scrollResponderHandleScrollEndDrag,\n        onScrollShouldSetResponder: this._scrollResponder.scrollResponderHandleScrollShouldSetResponder,\n        onStartShouldSetResponder: this._scrollResponder.scrollResponderHandleStartShouldSetResponder,\n        onStartShouldSetResponderCapture: this._scrollResponder.scrollResponderHandleStartShouldSetResponderCapture,\n        onTouchEnd: this._scrollResponder.scrollResponderHandleTouchEnd,\n        onTouchMove: this._scrollResponder.scrollResponderHandleTouchMove,\n        onTouchStart: this._scrollResponder.scrollResponderHandleTouchStart,\n        onTouchCancel: this._scrollResponder.scrollResponderHandleTouchCancel,\n        onScroll: this._handleScroll,\n        scrollBarThumbImage: resolveAssetSource(this.props.scrollBarThumbImage),\n        scrollEventThrottle: hasStickyHeaders ? 1 : this.props.scrollEventThrottle,\n        sendMomentumEvents: this.props.onMomentumScrollBegin || this.props.onMomentumScrollEnd ? true : false,\n        DEPRECATED_sendUpdatedChildFrames: DEPRECATED_sendUpdatedChildFrames,\n        snapToStart: this.props.snapToStart !== false,\n        snapToEnd: this.props.snapToEnd !== false,\n        pagingEnabled: Platform.select({\n          ios: this.props.pagingEnabled === true && this.props.snapToInterval == null && this.props.snapToOffsets == null,\n          android: this.props.pagingEnabled === true || this.props.snapToInterval != null || this.props.snapToOffsets != null\n        })\n      });\n\n      var decelerationRate = this.props.decelerationRate;\n\n      if (decelerationRate != null) {\n        props.decelerationRate = processDecelerationRate(decelerationRate);\n      }\n\n      var refreshControl = this.props.refreshControl;\n\n      if (refreshControl) {\n        if (Platform.OS === 'ios') {\n          return _reactJsxRuntime.jsxs(ScrollViewClass, _objectSpread(_objectSpread({}, props), {}, {\n            ref: this._setScrollViewRef,\n            children: [Platform.isTV ? null : refreshControl, contentContainer]\n          }));\n        } else if (Platform.OS === 'android') {\n          var _splitLayoutProps = splitLayoutProps(flattenStyle(props.style)),\n              outer = _splitLayoutProps.outer,\n              inner = _splitLayoutProps.inner;\n\n          return React.cloneElement(refreshControl, {\n            style: [baseStyle, outer]\n          }, _reactJsxRuntime.jsx(ScrollViewClass, _objectSpread(_objectSpread({}, props), {}, {\n            style: [baseStyle, inner],\n            ref: this._setScrollViewRef,\n            children: contentContainer\n          })));\n        }\n      }\n\n      return _reactJsxRuntime.jsx(ScrollViewClass, _objectSpread(_objectSpread({}, props), {}, {\n        ref: this._setScrollViewRef,\n        children: contentContainer\n      }));\n    }\n  }]);\n\n  return ScrollView;\n}(React.Component);\n\nvar styles = StyleSheet.create({\n  baseVertical: {\n    flexGrow: 1,\n    flexShrink: 1,\n    flexDirection: 'column',\n    overflow: 'scroll'\n  },\n  baseHorizontal: {\n    flexGrow: 1,\n    flexShrink: 1,\n    flexDirection: 'row',\n    overflow: 'scroll'\n  },\n  contentContainerHorizontal: {\n    flexDirection: 'row'\n  }\n});\nmodule.exports = ScrollView;","map":{"version":3,"sources":["/Users/mikebaker/health_tracker/client/node_modules/react-native-nested-scroll-view/lib/NestedScrollView.js"],"names":["React","require","View","ReactNative","Platform","StyleSheet","requireNativeComponent","AnimatedImplementation","ScrollResponder","ScrollViewStickyHeader","createReactClass","dismissKeyboard","flattenStyle","invariant","processDecelerationRate","warning","resolveAssetSource","AndroidScrollView","AndroidHorizontalScrollContentView","AndroidHorizontalScrollView","RCTScrollView","RCTScrollContentView","OS","createScrollResponder","node","scrollResponder","Mixin","key","bind","ScrollView","props","_scrollResponder","_scrollAnimatedValue","Value","_scrollAnimatedValueAttachment","_stickyHeaderRefs","Map","_headerLayoutYs","state","layoutHeight","scrollResponderMixinGetInitialState","_handleScroll","e","__DEV__","onScroll","scrollEventThrottle","console","log","keyboardDismissMode","isTouching","scrollResponderHandleScroll","_handleLayout","invertStickyHeaders","setState","nativeEvent","layout","height","onLayout","_handleContentOnLayout","width","onContentSizeChange","_scrollViewRef","_setScrollViewRef","ref","_innerViewRef","_setInnerViewRef","startsWith","Object","keys","filter","forEach","UNSAFE_componentWillMount","contentOffset","y","setOffset","contentInset","top","nextProps","currentContentInsetTop","nextContentInsetTop","_updateAnimatedNodeAttachment","detach","setNativeProps","findNodeHandle","options","deprecatedX","deprecatedAnimated","x","animated","warn","scrollResponderScrollTo","scrollResponderScrollToEnd","scrollTo","scrollResponderFlashScrollIndicators","index","childArray","child","stickyHeaderIndices","length","attachNativeEvent","set","delete","event","Children","toArray","children","_getKeyForIndex","layoutY","indexOfIndex","indexOf","previousHeaderIndex","previousHeader","get","setNextHeaderY","ScrollViewClass","ScrollContentContainerViewClass","horizontal","undefined","contentContainerStyle","styles","contentContainerHorizontal","style","childLayoutProps","prop","JSON","stringify","contentSizeChangeProps","map","nextIndex","_setStickyHeaderRef","_onStickyHeaderLayout","hasStickyHeaders","Array","isArray","contentContainer","removeClippedSubviews","alwaysBounceHorizontal","alwaysBounceVertical","DEPRECATED_sendUpdatedChildFrames","baseStyle","baseHorizontal","baseVertical","onMomentumScrollBegin","scrollResponderHandleMomentumScrollBegin","onMomentumScrollEnd","scrollResponderHandleMomentumScrollEnd","onResponderGrant","scrollResponderHandleResponderGrant","onResponderReject","scrollResponderHandleResponderReject","onResponderRelease","scrollResponderHandleResponderRelease","onResponderTerminate","scrollResponderHandleTerminate","onResponderTerminationRequest","scrollResponderHandleTerminationRequest","onScrollBeginDrag","scrollResponderHandleScrollBeginDrag","onScrollEndDrag","scrollResponderHandleScrollEndDrag","onScrollShouldSetResponder","scrollResponderHandleScrollShouldSetResponder","onStartShouldSetResponder","scrollResponderHandleStartShouldSetResponder","onStartShouldSetResponderCapture","scrollResponderHandleStartShouldSetResponderCapture","onTouchEnd","scrollResponderHandleTouchEnd","onTouchMove","scrollResponderHandleTouchMove","onTouchStart","scrollResponderHandleTouchStart","onTouchCancel","scrollResponderHandleTouchCancel","scrollBarThumbImage","sendMomentumEvents","snapToStart","snapToEnd","pagingEnabled","select","ios","snapToInterval","snapToOffsets","android","decelerationRate","refreshControl","isTV","splitLayoutProps","outer","inner","cloneElement","Component","create","flexGrow","flexShrink","flexDirection","overflow","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * Forked from https://github.com/facebook/react-native/blob/0.56-stable/Libraries/Components/ScrollView/ScrollView.js\n *\n * @format\n * @flow\n */\n\n'use strict';\n\nconst React = require('react');\nconst ReactNative = require('react-native');\n\nconst {\n  View,\n  Platform,\n  StyleSheet,\n  requireNativeComponent,\n} = ReactNative;\n\nconst AnimatedImplementation = require('react-native/Libraries/Animated/src/AnimatedImplementation');\nconst ScrollResponder = require('react-native/Libraries/Components/ScrollResponder');\nconst ScrollViewStickyHeader = require('react-native/Libraries/Components/ScrollView/ScrollViewStickyHeader');\n\nconst createReactClass = require('create-react-class');\nconst dismissKeyboard = require('react-native/Libraries/Utilities/dismissKeyboard');\nconst flattenStyle = require('react-native/Libraries/StyleSheet/flattenStyle');\nconst invariant = require('fbjs/lib/invariant');\nconst processDecelerationRate = require('react-native/Libraries/Components/ScrollView/processDecelerationRate');\nconst warning = require('fbjs/lib/warning');\nconst resolveAssetSource = require('react-native/Libraries/Image/resolveAssetSource');\n\nimport type {PressEvent} from 'CoreEventTypes';\nimport type {EdgeInsetsProp} from 'EdgeInsetsPropType';\nimport type {NativeMethodsMixinType} from 'ReactNativeTypes';\nimport type {ViewStyleProp} from 'StyleSheet';\nimport type {ViewProps} from 'ViewPropTypes';\nimport type {PointProp} from 'PointPropType';\n\nimport type {ColorValue} from 'StyleSheetTypes';\n\nlet AndroidScrollView;\nlet AndroidHorizontalScrollContentView;\nlet AndroidHorizontalScrollView;\nlet RCTScrollView;\nlet RCTScrollContentView;\n\nif (Platform.OS === 'android') {\n  AndroidScrollView = requireNativeComponent('RCTNestedScrollView');\n  AndroidHorizontalScrollView = requireNativeComponent(\n    'AndroidHorizontalNestedScrollView',\n  );\n  AndroidHorizontalScrollContentView = requireNativeComponent(\n    'AndroidHorizontalNestedScrollContentView',\n  );\n} else if (Platform.OS === 'ios') {\n  RCTScrollView = requireNativeComponent('RCTScrollView');\n  RCTScrollContentView = requireNativeComponent('RCTScrollContentView');\n} else {\n  RCTScrollView = requireNativeComponent('RCTScrollView');\n  RCTScrollContentView = requireNativeComponent('RCTScrollContentView');\n}\n\ntype TouchableProps = $ReadOnly<{|\n  onTouchStart?: (event: PressEvent) => void,\n  onTouchMove?: (event: PressEvent) => void,\n  onTouchEnd?: (event: PressEvent) => void,\n  onTouchCancel?: (event: PressEvent) => void,\n  onTouchEndCapture?: (event: PressEvent) => void,\n|}>;\n\ntype IOSProps = $ReadOnly<{|\n  /**\n   * Controls whether iOS should automatically adjust the content inset\n   * for scroll views that are placed behind a navigation bar or\n   * tab bar/ toolbar. The default value is true.\n   * @platform ios\n   */\n  automaticallyAdjustContentInsets?: ?boolean,\n  /**\n   * The amount by which the scroll view content is inset from the edges\n   * of the scroll view. Defaults to `{top: 0, left: 0, bottom: 0, right: 0}`.\n   * @platform ios\n   */\n  contentInset?: ?EdgeInsetsProp,\n  /**\n   * Used to manually set the starting scroll offset.\n   * The default value is `{x: 0, y: 0}`.\n   * @platform ios\n   */\n  contentOffset?: ?PointProp,\n  /**\n   * When true, the scroll view bounces when it reaches the end of the\n   * content if the content is larger then the scroll view along the axis of\n   * the scroll direction. When false, it disables all bouncing even if\n   * the `alwaysBounce*` props are true. The default value is true.\n   * @platform ios\n   */\n  bounces?: ?boolean,\n  /**\t\n   * By default, ScrollView has an active pan responder that hijacks panresponders\t\n   * deeper in the render tree in order to prevent accidental touches while scrolling.\t\n   * However, in certain occasions (such as when using snapToInterval) in a vertical scrollview\t\n   * You may want to disable this behavior in order to prevent the ScrollView from blocking touches\t\n   */\t\n  disableScrollViewPanResponder?: ?boolean,\n  /**\n   * When true, gestures can drive zoom past min/max and the zoom will animate\n   * to the min/max value at gesture end, otherwise the zoom will not exceed\n   * the limits.\n   * @platform ios\n   */\n  bouncesZoom?: ?boolean,\n  /**\n   * When true, the scroll view bounces horizontally when it reaches the end\n   * even if the content is smaller than the scroll view itself. The default\n   * value is true when `horizontal={true}` and false otherwise.\n   * @platform ios\n   */\n  alwaysBounceHorizontal?: ?boolean,\n  /**\n   * When true, the scroll view bounces vertically when it reaches the end\n   * even if the content is smaller than the scroll view itself. The default\n   * value is false when `horizontal={true}` and true otherwise.\n   * @platform ios\n   */\n  alwaysBounceVertical?: ?boolean,\n  /**\n   * When true, the scroll view automatically centers the content when the\n   * content is smaller than the scroll view bounds; when the content is\n   * larger than the scroll view, this property has no effect. The default\n   * value is false.\n   * @platform ios\n   */\n  centerContent?: ?boolean,\n  /**\n   * The style of the scroll indicators.\n   *\n   *   - `'default'` (the default), same as `black`.\n   *   - `'black'`, scroll indicator is black. This style is good against a light background.\n   *   - `'white'`, scroll indicator is white. This style is good against a dark background.\n   *\n   * @platform ios\n   */\n  indicatorStyle?: ?('default' | 'black' | 'white'),\n  /**\n   * When true, the ScrollView will try to lock to only vertical or horizontal\n   * scrolling while dragging.  The default value is false.\n   * @platform ios\n   */\n  directionalLockEnabled?: ?boolean,\n  /**\n   * When false, once tracking starts, won't try to drag if the touch moves.\n   * The default value is true.\n   * @platform ios\n   */\n  canCancelContentTouches?: ?boolean,\n  /**\n   * When set, the scroll view will adjust the scroll position so that the first child that is\n   * currently visible and at or beyond `minIndexForVisible` will not change position. This is\n   * useful for lists that are loading content in both directions, e.g. a chat thread, where new\n   * messages coming in might otherwise cause the scroll position to jump. A value of 0 is common,\n   * but other values such as 1 can be used to skip loading spinners or other content that should\n   * not maintain position.\n   *\n   * The optional `autoscrollToTopThreshold` can be used to make the content automatically scroll\n   * to the top after making the adjustment if the user was within the threshold of the top before\n   * the adjustment was made. This is also useful for chat-like applications where you want to see\n   * new messages scroll into place, but not if the user has scrolled up a ways and it would be\n   * disruptive to scroll a bunch.\n   *\n   * Caveat 1: Reordering elements in the scrollview with this enabled will probably cause\n   * jumpiness and jank. It can be fixed, but there are currently no plans to do so. For now,\n   * don't re-order the content of any ScrollViews or Lists that use this feature.\n   *\n   * Caveat 2: This simply uses `contentOffset` and `frame.origin` in native code to compute\n   * visibility. Occlusion, transforms, and other complexity won't be taken into account as to\n   * whether content is \"visible\" or not.\n   *\n   * @platform ios\n   */\n  maintainVisibleContentPosition?: ?$ReadOnly<{|\n    minIndexForVisible: number,\n    autoscrollToTopThreshold?: ?number,\n  |}>,\n  /**\n   * The maximum allowed zoom scale. The default value is 1.0.\n   * @platform ios\n   */\n  maximumZoomScale?: ?number,\n  /**\n   * The minimum allowed zoom scale. The default value is 1.0.\n   * @platform ios\n   */\n  minimumZoomScale?: ?number,\n  /**\n   * When true, ScrollView allows use of pinch gestures to zoom in and out.\n   * The default value is true.\n   * @platform ios\n   */\n  pinchGestureEnabled?: ?boolean,\n  /**\n   *\n   * Values between 0 and 17ms indicate 60fps updates are needed and throttling\t\n   * will be disabled.\t\n   *\n   * If you do not need precise scroll position tracking, set this value higher\t\n   * to limit the information being sent across the bridge.\t\n   *\n   * The default value is zero, which results in the scroll event being sent only\t\n   * once each time the view is scrolled.\t\n   *\n   * @platform ios\n   */\n  scrollEventThrottle?: ?number,\n  /**\n   * The amount by which the scroll view indicators are inset from the edges\n   * of the scroll view. This should normally be set to the same value as\n   * the `contentInset`. Defaults to `{0, 0, 0, 0}`.\n   * @platform ios\n   */\n  scrollIndicatorInsets?: ?EdgeInsetsProp,\n  /**\n   * When true, the scroll view can be programmatically scrolled beyond its\n   * content size. The default value is false.\n   * @platform ios\n   */\n  scrollToOverflowEnabled?: ?boolean,\n  /**\n   * When true, the scroll view scrolls to top when the status bar is tapped.\n   * The default value is true.\n   * @platform ios\n   */\n  scrollsToTop?: ?boolean,\n  /**\n   * Fires when the scroll view scrolls to top after the status bar has been tapped\n   * @platform ios\n   */\n  onScrollToTop?: (event: ScrollEvent) => void,\n  /**\n   * When true, shows a horizontal scroll indicator.\n   * The default value is true.\n   */\n  showsHorizontalScrollIndicator?: ?boolean,\n  /**\n   * When `snapToInterval` is set, `snapToAlignment` will define the relationship\n   * of the snapping to the scroll view.\n   *\n   *   - `'start'` (the default) will align the snap at the left (horizontal) or top (vertical)\n   *   - `'center'` will align the snap in the center\n   *   - `'end'` will align the snap at the right (horizontal) or bottom (vertical)\n   *\n   * @platform ios\n   */\n  snapToAlignment?: ?('start' | 'center' | 'end'),\n  /**\n   * The current scale of the scroll view content. The default value is 1.0.\n   * @platform ios\n   */\n  zoomScale?: ?number,\n  /**\n   * This property specifies how the safe area insets are used to modify the\n   * content area of the scroll view. The default value of this property is\n   * \"never\". Available on iOS 11 and later.\n   * @platform ios\n   */\n  contentInsetAdjustmentBehavior?: ?(\n    | 'automatic'\n    | 'scrollableAxes'\n    | 'never'\n    | 'always'\n  ),\n  /**\n   * When true, ScrollView will emit updateChildFrames data in scroll events,\n   * otherwise will not compute or emit child frame data.  This only exists\n   * to support legacy issues, `onLayout` should be used instead to retrieve\n   * frame data.\n   * The default value is false.\n   * @platform ios\n   */\n  DEPRECATED_sendUpdatedChildFrames?: ?boolean,\n|}>;\n\ntype AndroidProps = $ReadOnly<{|\n  /**\n   * Enables nested scrolling for Android API level 21+.\n   * Nested scrolling is supported by default on iOS\n   * @platform android\n   */\n  nestedScrollEnabled?: ?boolean,\n  /**\n   * Sometimes a scrollview takes up more space than its content fills. When this is\n   * the case, this prop will fill the rest of the scrollview with a color to avoid setting\n   * a background and creating unnecessary overdraw. This is an advanced optimization\n   * that is not needed in the general case.\n   * @platform android\n   */\n  endFillColor?: ?ColorValue,\n  /**\n   * Tag used to log scroll performance on this scroll view. Will force\n   * momentum events to be turned on (see sendMomentumEvents). This doesn't do\n   * anything out of the box and you need to implement a custom native\n   * FpsListener for it to be useful.\n   * @platform android\n   */\n  scrollPerfTag?: ?string,\n  /**\n   * Used to override default value of overScroll mode.\n   *\n   * Possible values:\n   *\n   *  - `'auto'` - Default value, allow a user to over-scroll\n   *    this view only if the content is large enough to meaningfully scroll.\n   *  - `'always'` - Always allow a user to over-scroll this view.\n   *  - `'never'` - Never allow a user to over-scroll this view.\n   *\n   * @platform android\n   */\n  overScrollMode?: ?('auto' | 'always' | 'never'),\n  /**\n   * Causes the scrollbars not to turn transparent when they are not in use.\n   * The default value is false.\n   *\n   * @platform android\n   */\n  persistentScrollbar?: ?boolean,\n|}>;\n\ntype VRProps = $ReadOnly<{|\n  /**\n   * Optionally an image can be used for the scroll bar thumb. This will\n   * override the color. While the image is loading or the image fails to\n   * load the color will be used instead. Use an alpha of 0 in the color\n   * to avoid seeing it while the image is loading.\n   *\n   * - `uri` - a string representing the resource identifier for the image, which\n   * should be either a local file path or the name of a static image resource\n   * - `number` - Opaque type returned by something like\n   * `import IMAGE from './image.jpg'`.\n   * @platform vr\n   */\n  scrollBarThumbImage?: ?($ReadOnly<{||}> | number), // Opaque type returned by import IMAGE from './image.jpg'\n|}>;\n\nexport type Props = $ReadOnly<{|\n  ...ViewProps,\n  ...TouchableProps,\n  ...IOSProps,\n  ...AndroidProps,\n  ...VRProps,\n\n  /**\n   * These styles will be applied to the scroll view content container which\n   * wraps all of the child views. Example:\n   *\n   * ```\n   * return (\n   *   <ScrollView contentContainerStyle={styles.contentContainer}>\n   *   </ScrollView>\n   * );\n   * ...\n   * const styles = StyleSheet.create({\n   *   contentContainer: {\n   *     paddingVertical: 20\n   *   }\n   * });\n   * ```\n   */\n  contentContainerStyle?: ?ViewStyleProp,\n  /**\n   * When true, the scroll view stops on the next index (in relation to scroll\n   * position at release) regardless of how fast the gesture is. This can be\n   * used for horizontal pagination when the page is less than the width of\n   * the ScrollView. The default value is false.\n   */\n  disableIntervalMomentum?: ?boolean,\n  /**\n   * A floating-point number that determines how quickly the scroll view\n   * decelerates after the user lifts their finger. You may also use string\n   * shortcuts `\"normal\"` and `\"fast\"` which match the underlying iOS settings\n   * for `UIScrollViewDecelerationRateNormal` and\n   * `UIScrollViewDecelerationRateFast` respectively.\n   *\n   *   - `'normal'`: 0.998 on iOS, 0.985 on Android (the default)\n   *   - `'fast'`: 0.99 on iOS, 0.9 on Android\n   */\n  decelerationRate?: ?('fast' | 'normal' | number),\n  /**\n   * When true, the scroll view's children are arranged horizontally in a row\n   * instead of vertically in a column. The default value is false.\n   */\n  horizontal?: ?boolean,\n  /**\n   * If sticky headers should stick at the bottom instead of the top of the\n   * ScrollView. This is usually used with inverted ScrollViews.\n   */\n  invertStickyHeaders?: ?boolean,\n  /**\n   * Determines whether the keyboard gets dismissed in response to a drag.\n   *\n   * *Cross platform*\n   *\n   *   - `'none'` (the default), drags do not dismiss the keyboard.\n   *   - `'on-drag'`, the keyboard is dismissed when a drag begins.\n   *\n   * *iOS Only*\n   *\n   *   - `'interactive'`, the keyboard is dismissed interactively with the drag and moves in\n   *     synchrony with the touch; dragging upwards cancels the dismissal.\n   *     On android this is not supported and it will have the same behavior as 'none'.\n   */\n  keyboardDismissMode?: ?(\n    | 'none' // default\n    | 'on-drag' // cross-platform\n    | 'interactive'\n  ), // ios only\n  /**\n   * Determines when the keyboard should stay visible after a tap.\n   *\n   *   - `'never'` (the default), tapping outside of the focused text input when the keyboard\n   *     is up dismisses the keyboard. When this happens, children won't receive the tap.\n   *   - `'always'`, the keyboard will not dismiss automatically, and the scroll view will not\n   *     catch taps, but children of the scroll view can catch taps.\n   *   - `'handled'`, the keyboard will not dismiss automatically when the tap was handled by\n   *     a children, (or captured by an ancestor).\n   *   - `false`, deprecated, use 'never' instead\n   *   - `true`, deprecated, use 'always' instead\n   */\n  keyboardShouldPersistTaps?: ?('always' | 'never' | 'handled' | true | false),\n  /**\n   * Called when the momentum scroll starts (scroll which occurs as the ScrollView glides to a stop).\n   */\n  onMomentumScrollBegin?: (event: ScrollEvent) => void,\n  /**\n   * Called when the momentum scroll ends (scroll which occurs as the ScrollView glides to a stop).\n   */\n  onMomentumScrollEnd?: (event: ScrollEvent) => void,\n\n  /**\n   * Fires at most once per frame during scrolling. The frequency of the\n   * events can be controlled using the `scrollEventThrottle` prop.\n   */\n  onScroll?: (event: ScrollEvent) => void,\n  /**\n   * Called when the user begins to drag the scroll view.\n   */\n  onScrollBeginDrag?: (event: ScrollEvent) => void,\n  /**\n   * Called when the user stops dragging the scroll view and it either stops\n   * or begins to glide.\n   */\n  onScrollEndDrag?: (event: ScrollEvent) => void,\n  /**\n   * Called when scrollable content view of the ScrollView changes.\n   *\n   * Handler function is passed the content width and content height as parameters:\n   * `(contentWidth, contentHeight)`\n   *\n   * It's implemented using onLayout handler attached to the content container\n   * which this ScrollView renders.\n   */\n  onContentSizeChange?: (contentWidth: number, contentHeight: number) => void,\n  onKeyboardDidShow?: (event: PressEvent) => void,\n  /**\n   * When true, the scroll view stops on multiples of the scroll view's size\n   * when scrolling. This can be used for horizontal pagination. The default\n   * value is false.\n   *\n   * Note: Vertical pagination is not supported on Android.\n   */\n  pagingEnabled?: ?boolean,\n\n  /**\n   * When false, the view cannot be scrolled via touch interaction.\n   * The default value is true.\n   *\n   * Note that the view can always be scrolled by calling `scrollTo`.\n   */\n  scrollEnabled?: ?boolean,\n  /**\n   * When true, shows a vertical scroll indicator.\n   * The default value is true.\n   */\n  showsVerticalScrollIndicator?: ?boolean,\n  /**\n   * An array of child indices determining which children get docked to the\n   * top of the screen when scrolling. For example, passing\n   * `stickyHeaderIndices={[0]}` will cause the first child to be fixed to the\n   * top of the scroll view. This property is not supported in conjunction\n   * with `horizontal={true}`.\n   */\n  stickyHeaderIndices?: ?$ReadOnlyArray<number>,\n  /**\n   * When set, causes the scroll view to stop at multiples of the value of\n   * `snapToInterval`. This can be used for paginating through children\n   * that have lengths smaller than the scroll view. Typically used in\n   * combination with `snapToAlignment` and `decelerationRate=\"fast\"`.\n   *\n   * Overrides less configurable `pagingEnabled` prop.\n   */\n  snapToInterval?: ?number,\n  /**\n   * When set, causes the scroll view to stop at the defined offsets.\n   * This can be used for paginating through variously sized children\n   * that have lengths smaller than the scroll view. Typically used in\n   * combination with `decelerationRate=\"fast\"`.\n   *\n   * Overrides less configurable `pagingEnabled` and `snapToInterval` props.\n   */\n  snapToOffsets?: ?$ReadOnlyArray<number>,\n  /**\n   * Use in conjuction with `snapToOffsets`. By default, the beginning\n   * of the list counts as a snap offset. Set `snapToStart` to false to disable\n   * this behavior and allow the list to scroll freely between its start and\n   * the first `snapToOffsets` offset.\n   * The default value is true.\n   */\n  snapToStart?: ?boolean,\n  /**\n   * Use in conjuction with `snapToOffsets`. By default, the end\n   * of the list counts as a snap offset. Set `snapToEnd` to false to disable\n   * this behavior and allow the list to scroll freely between its end and\n   * the last `snapToOffsets` offset.\n   * The default value is true.\n   */\n  snapToEnd?: ?boolean,\n  /**\n   * Experimental: When true, offscreen child views (whose `overflow` value is\n   * `hidden`) are removed from their native backing superview when offscreen.\n   * This can improve scrolling performance on long lists. The default value is\n   * true.\n   */\n  removeClippedSubviews?: ?boolean,\n  /**\n   * A RefreshControl component, used to provide pull-to-refresh\n   * functionality for the ScrollView. Only works for vertical ScrollViews\n   * (`horizontal` prop must be `false`).\n   *\n   * See [RefreshControl](docs/refreshcontrol.html).\n   */\n  // $FlowFixMe - how to handle generic type without existential opereator?\n  refreshControl?: ?React.Element<any>,\n  children?: React.Node,\n|}>;\n\ntype State = {|\n  layoutHeight: ?number,\n  ...ScrollResponderState,\n|};\nfunction createScrollResponder(\n  node: React.ElementRef<typeof ScrollView>,\n): typeof ScrollResponder.Mixin {\n  const scrollResponder = {...ScrollResponder.Mixin};\n  for (const key in scrollResponder) {\n    if (typeof scrollResponder[key] === 'function') {\n      scrollResponder[key] = scrollResponder[key].bind(node);\n    }\n  }\n  return scrollResponder;\n}\n\n/**\n * Component that wraps platform ScrollView while providing\n * integration with touch locking \"responder\" system.\n *\n * Keep in mind that ScrollViews must have a bounded height in order to work,\n * since they contain unbounded-height children into a bounded container (via\n * a scroll interaction). In order to bound the height of a ScrollView, either\n * set the height of the view directly (discouraged) or make sure all parent\n * views have bounded height. Forgetting to transfer `{flex: 1}` down the\n * view stack can lead to errors here, which the element inspector makes\n * easy to debug.\n *\n * Doesn't yet support other contained responders from blocking this scroll\n * view from becoming the responder.\n *\n *\n * `<ScrollView>` vs [`<FlatList>`](/react-native/docs/flatlist.html) - which one to use?\n *\n * `ScrollView` simply renders all its react child components at once. That\n * makes it very easy to understand and use.\n *\n * On the other hand, this has a performance downside. Imagine you have a very\n * long list of items you want to display, maybe several screens worth of\n * content. Creating JS components and native views for everything all at once,\n * much of which may not even be shown, will contribute to slow rendering and\n * increased memory usage.\n *\n * This is where `FlatList` comes into play. `FlatList` renders items lazily,\n * just when they are about to appear, and removes items that scroll way off\n * screen to save memory and processing time.\n *\n * `FlatList` is also handy if you want to render separators between your items,\n * multiple columns, infinite scroll loading, or any number of other features it\n * supports out of the box.\n */\nclass ScrollView extends React.Component<Props, State> {\n  /**\n   * Part 1: Removing ScrollResponder.Mixin:\n   *\n   * 1. Mixin methods should be flow typed. That's why we create a\n   *    copy of ScrollResponder.Mixin and attach it to this._scrollResponder.\n   *    Otherwise, we'd have to manually declare each method on the component\n   *    class and assign it a flow type.\n   * 2. Mixin methods can call component methods, and access the component's\n   *    props and state. So, we need to bind all mixin methods to the\n   *    component instance.\n   * 3. Continued...\n   */\n  _scrollResponder: typeof ScrollResponder.Mixin = createScrollResponder(this);\n  constructor(props: Props) {\n    super(props);\n    /**\n     * Part 2: Removing ScrollResponder.Mixin\n     *\n     * 3. Mixin methods access other mixin methods via dynamic dispatch using\n     *    this. Since mixin methods are bound to the component instance, we need\n     *    to copy all mixin methods to the component instance. This is also\n     *    necessary because getScrollResponder() is a public method that returns\n     *    an object that can be used to execute all scrollResponder methods.\n     *    Since the object returned from that method is the ScrollView instance,\n     *    we need to bind all mixin methods to the ScrollView instance.\n     */\n    for (const key in ScrollResponder.Mixin) {\n      if (\n        typeof ScrollResponder.Mixin[key] === 'function' &&\n        key.startsWith('scrollResponder')\n      ) {\n        // $FlowFixMe - dynamically adding properties to a class\n        (this: any)[key] = ScrollResponder.Mixin[key].bind(this);\n      }\n    }\n    /**\n     * Part 3: Removing ScrollResponder.Mixin\n     *\n     * 4. Mixins can initialize properties and use properties on the component\n     *    instance.\n     */\n    Object.keys(ScrollResponder.Mixin)\n      .filter(key => typeof ScrollResponder.Mixin[key] !== 'function')\n      .forEach(key => {\n        // $FlowFixMe - dynamically adding properties to a class\n        (this: any)[key] = ScrollResponder.Mixin[key];\n      });\n  }\n\n  _scrollAnimatedValue: AnimatedImplementation.Value = new AnimatedImplementation.Value(\n    0,\n  );\n  _scrollAnimatedValueAttachment: ?{detach: () => void} = null;\n  _stickyHeaderRefs: Map<number, ScrollViewStickyHeader> = new Map();\n  _headerLayoutYs: Map<string, number> = new Map();\n\n\n  state = {\n    layoutHeight: null,\n    ...ScrollResponder.Mixin.scrollResponderMixinGetInitialState(),\n  };\n\n  UNSAFE_componentWillMount() {\n    this._scrollResponder.UNSAFE_componentWillMount();\n    this._scrollAnimatedValue = new AnimatedImplementation.Value(\n      this.props.contentOffset ? this.props.contentOffset.y : 0,\n    );\n    this._scrollAnimatedValue.setOffset(\n      /* $FlowFixMe(>=0.98.0 site=react_native_fb) This comment suppresses an\n       * error found when Flow v0.98 was deployed. To see the error delete this\n       * comment and run Flow. */\n      this.props.contentInset ? this.props.contentInset.top : 0,\n    );\n    this._stickyHeaderRefs = new Map();\n    this._headerLayoutYs = new Map();\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps: Props) {\n    const currentContentInsetTop = this.props.contentInset\n    ? this.props.contentInset.top\n    : 0;\n    const nextContentInsetTop = nextProps.contentInset\n    ? nextProps.contentInset.top\n    : 0;\n    if (currentContentInsetTop !== nextContentInsetTop) {\n      this._scrollAnimatedValue.setOffset(nextContentInsetTop || 0);\n    }\n  }\n\n  componentDidMount() {\n    this._updateAnimatedNodeAttachment();\n  }\n\n  componentDidUpdate() {\n    this._updateAnimatedNodeAttachment();\n  }\n\n  componentWillUnmount() {\n    if (this._scrollAnimatedValueAttachment) {\n      this._scrollAnimatedValueAttachment.detach();\n    }\n  }\n\n  setNativeProps(props: {[key: string]: mixed}) {\n    this._scrollViewRef && this._scrollViewRef.setNativeProps(props);\n  }\n\n  /**\n   * Returns a reference to the underlying scroll responder, which supports\n   * operations like `scrollTo`. All ScrollView-like components should\n   * implement this method so that they can be composed while providing access\n   * to the underlying scroll responder's methods.\n   */\n  getScrollResponder(): ScrollResponderType {\n    // $FlowFixMe - overriding type to include ScrollResponder.Mixin\n    return ((this: any): ScrollResponderType);\n  }\n\n  getScrollableNode(): ?number {\n    return ReactNative.findNodeHandle(this._scrollViewRef);\n  }\n\n  getInnerViewNode(): ?number {\n    return ReactNative.findNodeHandle(this._innerViewRef);\n  }\n\n  getNativeScrollRef(): ?ScrollView {\n    return this._scrollViewRef;\n  }\n\n  /**\n   * Scrolls to a given x, y offset, either immediately or with a smooth animation.\n   *\n   * Example:\n   *\n   * `scrollTo({x: 0, y: 0, animated: true})`\n   *\n   * Note: The weird function signature is due to the fact that, for historical reasons,\n   * the function also accepts separate arguments as an alternative to the options object.\n   * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.\n   */\n  scrollTo(\n    options?: {x?: number, y?: number, animated?: boolean} | number,\n    deprecatedX?: number,\n    deprecatedAnimated?: boolean,\n  ) {\n    let x, y, animated;\n    if (typeof options === 'number') {\n      console.warn(\n        '`scrollTo(y, x, animated)` is deprecated. Use `scrollTo({x: 5, y: 5, ' +\n          'animated: true})` instead.',\n      );\n      y = options;\n      x = deprecatedX;\n      animated = deprecatedAnimated;\n    } else if (options) {\n      y = options.y;\n      x = options.x;\n      animated = options.animated;\n    }\n    this._scrollResponder.scrollResponderScrollTo({\n      x: x || 0,\n      y: y || 0,\n      animated: animated !== false,\n    });\n  }\n\n  /**\n   * If this is a vertical ScrollView scrolls to the bottom.\n   * If this is a horizontal ScrollView scrolls to the right.\n   *\n   * Use `scrollToEnd({animated: true})` for smooth animated scrolling,\n   * `scrollToEnd({animated: false})` for immediate scrolling.\n   * If no options are passed, `animated` defaults to true.\n   */\n  scrollToEnd(options?: ?{animated?: boolean}) {\n    // Default to true\n    const animated = (options && options.animated) !== false;\n    this._scrollResponder.scrollResponderScrollToEnd({\n      animated: animated,\n    });\n  }\n\n  /**\n   * Deprecated, use `scrollTo` instead.\n   */\n  scrollWithoutAnimationTo(y: number = 0, x: number = 0) {\n    console.warn(\n      '`scrollWithoutAnimationTo` is deprecated. Use `scrollTo` instead',\n    );\n    this.scrollTo({x, y, animated: false});\n  }\n\n  /**\n   * Displays the scroll indicators momentarily.\n   *\n   * @platform ios\n   */\n  flashScrollIndicators() {\n    this._scrollResponder.scrollResponderFlashScrollIndicators();\n  }\n\n  _getKeyForIndex(index, childArray) {\n    // $FlowFixMe Invalid prop usage\n    const child = childArray[index];\n    return child && child.key;\n  }\n\n  _updateAnimatedNodeAttachment() {\n    if (this._scrollAnimatedValueAttachment) {\n      this._scrollAnimatedValueAttachment.detach();\n    }\n    if (\n      this.props.stickyHeaderIndices &&\n      this.props.stickyHeaderIndices.length > 0\n    ) {\n      this._scrollAnimatedValueAttachment = AnimatedImplementation.attachNativeEvent(\n        this._scrollViewRef,\n        'onScroll',\n        [{nativeEvent: {contentOffset: {y: this._scrollAnimatedValue}}}],\n      );\n    }\n  }\n\n  _setStickyHeaderRef(key, ref) {\n    if (ref) {\n      this._stickyHeaderRefs.set(key, ref);\n    } else {\n      this._stickyHeaderRefs.delete(key);\n    }\n  }\n\n  _onStickyHeaderLayout(index, event, key) {\n    const {stickyHeaderIndices} = this.props;\n    if (!stickyHeaderIndices) {\n      return;\n    }\n    const childArray = React.Children.toArray(this.props.children);\n    if (key !== this._getKeyForIndex(index, childArray)) {\n      // ignore stale layout update\n      return;\n    }\n    const layoutY = event.nativeEvent.layout.y;\n    this._headerLayoutYs.set(key, layoutY);\n    const indexOfIndex = stickyHeaderIndices.indexOf(index);\n    const previousHeaderIndex = stickyHeaderIndices[indexOfIndex - 1];\n    if (previousHeaderIndex != null) {\n      const previousHeader = this._stickyHeaderRefs.get(\n        this._getKeyForIndex(previousHeaderIndex, childArray),\n      );\n      previousHeader && previousHeader.setNextHeaderY(layoutY);\n    }\n  }\n\n  _handleScroll = (e: ScrollEvent) => {\n    if (__DEV__) {\n      if (\n        this.props.onScroll &&\n        this.props.scrollEventThrottle == null &&\n        Platform.OS === 'ios'\n      ) {\n        console.log(\n          'You specified `onScroll` on a <ScrollView> but not ' +\n            '`scrollEventThrottle`. You will only receive one event. ' +\n            'Using `16` you get all the events but be aware that it may ' +\n            \"cause frame drops, use a bigger number if you don't need as \" +\n            'much precision.',\n        );\n      }\n    }\n    if (Platform.OS === 'android') {\n      if (\n        this.props.keyboardDismissMode === 'on-drag' &&\n        this.state.isTouching\n      ) {\n        dismissKeyboard();\n      }\n    }\n    this._scrollResponder.scrollResponderHandleScroll(e);\n  }\n\n  _handleLayout = (e: LayoutEvent) => {\n    if (this.props.invertStickyHeaders === true) {\n      this.setState({layoutHeight: e.nativeEvent.layout.height});\n    }\n    if (this.props.onLayout) {\n      this.props.onLayout(e);\n    }\n  };\n\n  _handleContentOnLayout = (e: LayoutEvent) => {\n    const {width, height} = e.nativeEvent.layout;\n    this.props.onContentSizeChange &&\n      this.props.onContentSizeChange(width, height);\n  };\n\n  _scrollViewRef: ?ScrollView = null;\n  _setScrollViewRef = (ref: ?ScrollView) => {\n    this._scrollViewRef = ref;\n  };\n\n  _innerViewRef: ?NativeMethodsMixinType = null;\n  _setInnerViewRef = (ref: ?NativeMethodsMixinType) => {\n    this._innerViewRef = ref;\n  };\n\n  render() {\n    let ScrollViewClass;\n    let ScrollContentContainerViewClass;\n    if (Platform.OS === 'android') {\n      if (this.props.horizontal === true) {\n        ScrollViewClass = AndroidHorizontalScrollView;\n        ScrollContentContainerViewClass = AndroidHorizontalScrollContentView;\n      } else {\n        ScrollViewClass = AndroidScrollView;\n        ScrollContentContainerViewClass = View;\n      }\n    } else {\n      ScrollViewClass = RCTScrollView;\n      ScrollContentContainerViewClass = RCTScrollContentView;\n    }\n\n    invariant(\n      ScrollViewClass !== undefined,\n      'ScrollViewClass must not be undefined',\n    );\n\n    invariant(\n      ScrollContentContainerViewClass !== undefined,\n      'ScrollContentContainerViewClass must not be undefined',\n    );\n\n    const contentContainerStyle = [\n      this.props.horizontal === true && styles.contentContainerHorizontal,\n      this.props.contentContainerStyle,\n    ];\n    if (__DEV__ && this.props.style !== undefined) {\n      const style = flattenStyle(this.props.style);\n      const childLayoutProps = ['alignItems', 'justifyContent'].filter(\n        prop => style && style[prop] !== undefined,\n      );\n      invariant(\n        childLayoutProps.length === 0,\n        'ScrollView child layout (' +\n          JSON.stringify(childLayoutProps) +\n          ') must be applied through the contentContainerStyle prop.',\n      );\n    }\n\n    let contentSizeChangeProps = {};\n    if (this.props.onContentSizeChange) {\n      contentSizeChangeProps = {\n        onLayout: this._handleContentOnLayout,\n      };\n    }\n\n    const {stickyHeaderIndices} = this.props;\n    let children = this.props.children;\n    if (stickyHeaderIndices != null && stickyHeaderIndices.length > 0) {\n      const childArray = React.Children.toArray(this.props.children);\n      children = childArray.map((child, index) => {\n        const indexOfIndex = child ? stickyHeaderIndices.indexOf(index) : -1;\n        if (indexOfIndex > -1) {\n          const key = child.key;\n          const nextIndex = stickyHeaderIndices[indexOfIndex + 1];\n          return (\n            <ScrollViewStickyHeader\n              key={key}\n              ref={ref => this._setStickyHeaderRef(key, ref)}\n              nextHeaderLayoutY={this._headerLayoutYs.get(\n                this._getKeyForIndex(nextIndex, childArray),\n              )}\n              onLayout={event => this._onStickyHeaderLayout(index, event, key)}\n              scrollAnimatedValue={this._scrollAnimatedValue}\n              inverted={this.props.invertStickyHeaders}\n              scrollViewHeight={this.state.layoutHeight}>\n              {child}\n            </ScrollViewStickyHeader>\n          );\n        } else {\n          return child;\n        }\n      });\n    }\n    const hasStickyHeaders =\n      Array.isArray(stickyHeaderIndices) && stickyHeaderIndices.length > 0;\n\n    const contentContainer = (\n      <ScrollContentContainerViewClass\n        {...contentSizeChangeProps}\n        // $FlowFixMe Invalid prop usage\n        ref={this._setInnerViewRef}\n        style={contentContainerStyle}\n        removeClippedSubviews={\n          // Subview clipping causes issues with sticky headers on Android and\n          // would be hard to fix properly in a performant way.\n          Platform.OS === 'android' && hasStickyHeaders\n            ? false\n            : this.props.removeClippedSubviews\n        }\n        collapsable={false}>\n        {children}\n      </ScrollContentContainerViewClass>\n    );\n\n    const alwaysBounceHorizontal =\n      this.props.alwaysBounceHorizontal !== undefined\n        ? this.props.alwaysBounceHorizontal\n        : this.props.horizontal;\n\n    const alwaysBounceVertical =\n      this.props.alwaysBounceVertical !== undefined\n        ? this.props.alwaysBounceVertical\n        : !this.props.horizontal;\n\n    const DEPRECATED_sendUpdatedChildFrames = !!this.props\n      .DEPRECATED_sendUpdatedChildFrames;\n\n    const baseStyle =\n      this.props.horizontal === true\n        ? styles.baseHorizontal\n        : styles.baseVertical;\n    const props = {\n      ...this.props,\n      alwaysBounceHorizontal,\n      alwaysBounceVertical,\n      style: [baseStyle, this.props.style],\n      // Override the onContentSizeChange from props, since this event can\n      // bubble up from TextInputs\n      onContentSizeChange: null,\n      onLayout: this._handleLayout,\n      onMomentumScrollBegin: this._scrollResponder\n        .scrollResponderHandleMomentumScrollBegin,\n      onMomentumScrollEnd: this._scrollResponder\n        .scrollResponderHandleMomentumScrollEnd,\n      onResponderGrant: this._scrollResponder\n        .scrollResponderHandleResponderGrant,\n      onResponderReject: this._scrollResponder\n        .scrollResponderHandleResponderReject,\n      onResponderRelease: this._scrollResponder\n        .scrollResponderHandleResponderRelease,\n      // $FlowFixMe\n      onResponderTerminate: this._scrollResponder\n        .scrollResponderHandleTerminate,\n      onResponderTerminationRequest: this._scrollResponder\n        .scrollResponderHandleTerminationRequest,\n      onScrollBeginDrag: this._scrollResponder\n        .scrollResponderHandleScrollBeginDrag,\n      onScrollEndDrag: this._scrollResponder.scrollResponderHandleScrollEndDrag,\n      onScrollShouldSetResponder: this._scrollResponder\n        .scrollResponderHandleScrollShouldSetResponder,\n      onStartShouldSetResponder: this._scrollResponder\n        .scrollResponderHandleStartShouldSetResponder,\n      onStartShouldSetResponderCapture: this._scrollResponder\n        .scrollResponderHandleStartShouldSetResponderCapture,\n      onTouchEnd: this._scrollResponder.scrollResponderHandleTouchEnd,\n      onTouchMove: this._scrollResponder.scrollResponderHandleTouchMove,\n      onTouchStart: this._scrollResponder.scrollResponderHandleTouchStart,\n      onTouchCancel: this._scrollResponder.scrollResponderHandleTouchCancel,\n      onScroll: this._handleScroll,\n      scrollBarThumbImage: resolveAssetSource(this.props.scrollBarThumbImage),\n      scrollEventThrottle: hasStickyHeaders\n        ? 1\n        : this.props.scrollEventThrottle,\n      sendMomentumEvents:\n        this.props.onMomentumScrollBegin || this.props.onMomentumScrollEnd\n          ? true\n          : false,\n      DEPRECATED_sendUpdatedChildFrames,\n      // default to true\n      snapToStart: this.props.snapToStart !== false,\n      // default to true\n      snapToEnd: this.props.snapToEnd !== false,\n      // pagingEnabled is overridden by snapToInterval / snapToOffsets\n      pagingEnabled: Platform.select({\n        // on iOS, pagingEnabled must be set to false to have snapToInterval / snapToOffsets work\n        ios:\n          this.props.pagingEnabled === true &&\n          this.props.snapToInterval == null &&\n          this.props.snapToOffsets == null,\n        // on Android, pagingEnabled must be set to true to have snapToInterval / snapToOffsets work\n        android:\n          this.props.pagingEnabled === true ||\n          this.props.snapToInterval != null ||\n          this.props.snapToOffsets != null,\n      }),\n    };\n\n    const {decelerationRate} = this.props;\n    if (decelerationRate != null) {\n      props.decelerationRate = processDecelerationRate(decelerationRate);\n    }\n\n    const refreshControl = this.props.refreshControl;\n\n    if (refreshControl) {\n      if (Platform.OS === 'ios') {\n        // On iOS the RefreshControl is a child of the ScrollView.\n        // tvOS lacks native support for RefreshControl, so don't include it in that case\n        return (\n          // $FlowFixMe\n          <ScrollViewClass {...props} ref={this._setScrollViewRef}>\n            {Platform.isTV ? null : refreshControl}\n            {contentContainer}\n          </ScrollViewClass>\n        );\n      } else if (Platform.OS === 'android') {\n        // On Android wrap the ScrollView with a AndroidSwipeRefreshLayout.\n        // Since the ScrollView is wrapped add the style props to the\n        // AndroidSwipeRefreshLayout and use flex: 1 for the ScrollView.\n        // Note: we should split props.style on the inner and outer props\n        // however, the ScrollView still needs the baseStyle to be scrollable\n        const {outer, inner} = splitLayoutProps(flattenStyle(props.style));\n        return React.cloneElement(\n          refreshControl,\n          {style: [baseStyle, outer]},\n          <ScrollViewClass\n            {...props}\n            style={[baseStyle, inner]}\n            // $FlowFixMe\n            ref={this._setScrollViewRef}>\n            {contentContainer}\n          </ScrollViewClass>,\n        );\n      }\n    }\n    return (\n      // FlowFixMe\n      <ScrollViewClass {...props} ref={this._setScrollViewRef}>\n        {contentContainer}\n      </ScrollViewClass>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  baseVertical: {\n    flexGrow: 1,\n    flexShrink: 1,\n    flexDirection: 'column',\n    overflow: 'scroll',\n  },\n  baseHorizontal: {\n    flexGrow: 1,\n    flexShrink: 1,\n    flexDirection: 'row',\n    overflow: 'scroll',\n  },\n  contentContainerHorizontal: {\n    flexDirection: 'row',\n  },\n});\n\nmodule.exports = ScrollView;\n"]},"metadata":{},"sourceType":"script"}